abs = (n) -> if n < 0 then -1 * n else n;

all = (list, function = bool) ->
    if not list then 1
    else if not function(head(list)) then 0
    else self(tail(list), function);

any = (list, function = bool) ->
    if not list then 0
    else if function(head(list)) then 1
    else self(tail(list), function);

bool = (x) -> if x then 1 else 0;

count = (element, list) ->
    if not list then 0
    else if head(list) == element then 1 + self(element, tail(list))
    else self(element, tail(list));

factorial = (n) ->
    if n <= 1 then 1
    else n * self(n - 1);

enumerate = (list, start = 0) ->
    if not list then []
    else [[start, head(list)]] + self(tail(list), start + 1);

filter = (list, function = bool) ->
    if not list then list
    else if function(head(list)) then head(list) + self(tail(list), function)
    else self(tail(list), function);

index_helper = (element, list, i) ->
    if not list then -1
    else if element == head(list) then i
    else self(element, tail(list), i + 1);

index = (element, list) -> index_helper(element, list, 0);

insert = (element, index, list) ->
    if not list then
        case type(list) when "List" then [element]
        when "String" then element
        else list
    else if index <= 0 then element + list
    else head(list) + self(element, index - 1, tail(list));

intersperse = (element, list) ->
    if not list then [element]
    else if not tail(list) then [head(list), element]
    else [head(list), element] + self(element, tail(list));

last = (list) -> reduce(list);

length = (list) ->
    if not list then 0
    else 1 + self(tail(list));

list = (string) ->
    if not string then []
    else head(string) + self(tail(string));

map = (function, list) ->
    if not list then list
    else if type(function) == "Function" then function(head(list)) + self(function, tail(list))
    else function + self(function, tail(list));

max = (list) -> reduce(list, (x, y) -> if x > y then x else y);

member = (element, list) ->
    if not list then 0
    else if element == head(list) then 1
    else self(element, tail(list));

min = (list) -> reduce(list, (x, y) -> if x < y then x else y);

power = (base, exponent) ->
    if base == 0 then 0
    else if exponent <= 0 then 1
    else if exponent == 1 then base
    else base * self(base, exponent - 1);

product = (list) -> reduce(list, (x, y) -> x * y);

range = (start, end = null, step = 1) ->
    if end == null then self(0, start, step)
    else if start >= end then []
    else start + self(start + step, end, step);

reduce = (list, function = (x, y) -> y) ->
    if not list then null
    else if not tail(list) then head(list)
    else function(head(list), self(tail(list), function));

reject = (list, function = bool) ->
    if not list then list
    else if not function(head(list)) then head(list) + self(tail(list), function)
    else self(tail(list), function);

remove = (index, list) ->
    if not list then list
    else if index <= 0 then tail(list)
    else head(list) + self(index - 1, tail(list));

repeat = (element, times = 1) ->
    if times < 0 then null
    else element + self(element, times - 1);

reverse = (list) ->
    if not list then list
    else self(tail(list)) + head(list);

string = (list) ->
    if not list then ""
    else head(list) + self(tail(list));

sum = (list) -> reduce(list, (x, y) -> x + y);